import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { createClient } from "@/lib/supabase/server";

// Deadline type mappings for schools (from SchoolDeadlineYear)
// type: "action" = completable deadline, "milestone" = informational date marker
const SCHOOL_DEADLINE_TYPES = {
  early_decision: { field: "deadlineEd", label: "Early Decision", type: "action" as const },
  early_decision_2: { field: "deadlineEd2", label: "Early Decision II", type: "action" as const },
  early_action: { field: "deadlineEa", label: "Early Action", type: "action" as const },
  regular_decision: { field: "deadlineRd", label: "Regular Decision", type: "action" as const },
  priority: { field: "deadlinePriority", label: "Priority Deadline", type: "action" as const },
  financial_aid: { field: "deadlineFinancialAid", label: "Financial Aid", type: "action" as const },
} as const;

// Get current admissions cycle
function getCurrentAdmissionsCycle(): number {
  const now = new Date();
  // If we're past August, we're applying for next year's fall
  return now.getMonth() >= 7 ? now.getFullYear() + 1 : now.getFullYear();
}

// Deadline type mappings for summer programs
const PROGRAM_DEADLINE_TYPES = {
  application_opens: { field: "applicationOpens", label: "Application Opens", type: "milestone" as const },
  early_deadline: { field: "earlyDeadline", label: "Early Deadline", type: "action" as const },
  application_deadline: { field: "applicationDeadline", label: "Application Deadline", type: "action" as const },
  notification: { field: "notificationDate", label: "Notification Date", type: "milestone" as const },
  program_start: { field: "startDate", label: "Program Starts", type: "milestone" as const },
  program_end: { field: "endDate", label: "Program Ends", type: "milestone" as const },
} as const;

// Default action templates for programs (these are common tasks students need to do)
const DEFAULT_PROGRAM_ACTIONS = [
  { title: "Research program", daysOffset: -30, category: "research" },
  { title: "Request recommendation letters", daysOffset: -21, category: "materials" },
  { title: "Write essays/personal statement", daysOffset: -14, category: "materials" },
  { title: "Submit application", daysOffset: 0, category: "submission" },
];

// Default action templates for schools
const DEFAULT_SCHOOL_ACTIONS = [
  { title: "Research school", daysOffset: -45, category: "research" },
  { title: "Request recommendation letters", daysOffset: -30, category: "materials" },
  { title: "Write supplemental essays", daysOffset: -14, category: "materials" },
  { title: "Submit application", daysOffset: 0, category: "submission" },
];

type SchoolDeadlineType = keyof typeof SCHOOL_DEADLINE_TYPES;
type ProgramDeadlineType = keyof typeof PROGRAM_DEADLINE_TYPES;

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const profile = await prisma.studentProfile.findUnique({
      where: { userId: user.id },
      select: { id: true },
    });

    if (!profile) {
      return NextResponse.json({ error: "Profile not found" }, { status: 404 });
    }

    const body = await request.json();
    const { type, sourceId, deadlines, applicationType } = body as {
      type: "school" | "program";
      sourceId: string;
      deadlines: string[];
      applicationType?: string; // For schools: "ed" | "ea" | "rd" etc.
    };

    if (!type || !sourceId || !deadlines || !Array.isArray(deadlines)) {
      return NextResponse.json(
        { error: "Missing required fields: type, sourceId, deadlines" },
        { status: 400 }
      );
    }

    let goalTitle: string;
    let goalCategory = "application";
    let createdGoal;
    let createdTasks: Array<{ id: string; title: string; dueDate: Date | null }> = [];

    if (type === "school") {
      // Get school details with current year's deadlines
      const currentCycle = getCurrentAdmissionsCycle();
      const school = await prisma.school.findUnique({
        where: { id: sourceId },
        include: {
          deadlineYears: {
            where: { admissionsCycle: currentCycle },
            take: 1,
          },
        },
      });

      if (!school) {
        return NextResponse.json({ error: "School not found" }, { status: 404 });
      }

      const yearDeadlines = school.deadlineYears[0];

      // Check if a goal already exists for this school
      let existingGoal = await prisma.goal.findFirst({
        where: {
          studentProfileId: profile.id,
          schoolId: sourceId,
          isAutoGenerated: true,
        },
      });

      if (!existingGoal) {
        // Create the application goal
        goalTitle = `Apply to ${school.name}`;
        existingGoal = await prisma.goal.create({
          data: {
            studentProfileId: profile.id,
            title: goalTitle,
            category: goalCategory,
            status: "planning",
            schoolId: sourceId,
            isAutoGenerated: true,
          },
        });
      }

      createdGoal = existingGoal;

      // Create tasks for each selected deadline (using SchoolDeadlineYear)
      for (const deadlineType of deadlines) {
        const deadlineInfo = SCHOOL_DEADLINE_TYPES[deadlineType as SchoolDeadlineType];
        if (!deadlineInfo) continue;

        // Get deadline from yearDeadlines if available
        const dueDate = yearDeadlines
          ? (yearDeadlines[deadlineInfo.field as keyof typeof yearDeadlines] as Date | null)
          : null;

        // Check if task already exists
        const existingTask = await prisma.task.findFirst({
          where: {
            studentProfileId: profile.id,
            schoolId: sourceId,
            deadlineType: deadlineType,
          },
        });

        if (!existingTask) {
          const task = await prisma.task.create({
            data: {
              studentProfileId: profile.id,
              goalId: existingGoal.id,
              title: `${school.name} ${deadlineInfo.label}`,
              type: deadlineInfo.type,
              dueDate,
              deadlineType,
              schoolId: sourceId,
              isAutoGenerated: true,
              isHardDeadline: deadlineInfo.type === "action",
              status: "pending",
            },
          });

          createdTasks.push({
            id: task.id,
            title: task.title,
            dueDate: task.dueDate,
          });
        }
      }

      // Also create default action tasks if they selected "include_actions"
      if (deadlines.includes("include_actions") && yearDeadlines) {
        const primaryDeadlineType = deadlines.find(d =>
          ["early_decision", "early_action", "regular_decision"].includes(d)
        ) as SchoolDeadlineType | undefined;

        const primaryDeadlineField = primaryDeadlineType
          ? SCHOOL_DEADLINE_TYPES[primaryDeadlineType].field
          : "deadlineRd";
        const primaryDeadline = yearDeadlines[primaryDeadlineField as keyof typeof yearDeadlines] as Date | null;

        if (primaryDeadline) {
          for (const template of DEFAULT_SCHOOL_ACTIONS) {
            const existingAction = await prisma.task.findFirst({
              where: {
                studentProfileId: profile.id,
                goalId: existingGoal.id,
                title: { contains: template.title },
              },
            });

            if (!existingAction) {
              const dueDate = new Date(primaryDeadline);
              dueDate.setDate(dueDate.getDate() + template.daysOffset);

              const task = await prisma.task.create({
                data: {
                  studentProfileId: profile.id,
                  goalId: existingGoal.id,
                  title: `${template.title} - ${school.name}`,
                  type: "action",
                  dueDate,
                  schoolId: sourceId,
                  isAutoGenerated: true,
                  isHardDeadline: false,
                  status: "pending",
                },
              });

              createdTasks.push({
                id: task.id,
                title: task.title,
                dueDate: task.dueDate,
              });
            }
          }
        }
      }
    } else if (type === "program") {
      // Get program details
      const program = await prisma.summerProgram.findUnique({
        where: { id: sourceId },
      });

      if (!program) {
        return NextResponse.json({ error: "Program not found" }, { status: 404 });
      }

      // Check if a goal already exists for this program
      let existingGoal = await prisma.goal.findFirst({
        where: {
          studentProfileId: profile.id,
          summerProgramId: sourceId,
          isAutoGenerated: true,
        },
      });

      if (!existingGoal) {
        // Create the application goal
        goalTitle = `Apply to ${program.shortName || program.name}`;
        existingGoal = await prisma.goal.create({
          data: {
            studentProfileId: profile.id,
            title: goalTitle,
            category: "research",
            status: "planning",
            summerProgramId: sourceId,
            isAutoGenerated: true,
          },
        });
      }

      createdGoal = existingGoal;

      // Create tasks for each selected deadline
      for (const deadlineType of deadlines) {
        const deadlineInfo = PROGRAM_DEADLINE_TYPES[deadlineType as ProgramDeadlineType];
        if (!deadlineInfo) continue;

        const dueDate = program[deadlineInfo.field as keyof typeof program] as Date | null;

        // Check if task already exists
        const existingTask = await prisma.task.findFirst({
          where: {
            studentProfileId: profile.id,
            summerProgramId: sourceId,
            deadlineType: deadlineType,
          },
        });

        if (!existingTask) {
          const task = await prisma.task.create({
            data: {
              studentProfileId: profile.id,
              goalId: existingGoal.id,
              title: `${program.shortName || program.name} ${deadlineInfo.label}`,
              type: deadlineInfo.type,
              dueDate,
              deadlineType,
              summerProgramId: sourceId,
              isAutoGenerated: true,
              isHardDeadline: deadlineInfo.type === "action",
              status: "pending",
            },
          });

          createdTasks.push({
            id: task.id,
            title: task.title,
            dueDate: task.dueDate,
          });
        }
      }

      // Also create default action tasks if they selected "include_actions"
      if (deadlines.includes("include_actions")) {
        const primaryDeadline = program.applicationDeadline || program.earlyDeadline;

        if (primaryDeadline) {
          for (const template of DEFAULT_PROGRAM_ACTIONS) {
            const existingAction = await prisma.task.findFirst({
              where: {
                studentProfileId: profile.id,
                goalId: existingGoal.id,
                title: { contains: template.title },
              },
            });

            if (!existingAction) {
              const dueDate = new Date(primaryDeadline);
              dueDate.setDate(dueDate.getDate() + template.daysOffset);

              const task = await prisma.task.create({
                data: {
                  studentProfileId: profile.id,
                  goalId: existingGoal.id,
                  title: `${template.title} - ${program.shortName || program.name}`,
                  type: "action",
                  dueDate,
                  summerProgramId: sourceId,
                  isAutoGenerated: true,
                  isHardDeadline: false,
                  status: "pending",
                },
              });

              createdTasks.push({
                id: task.id,
                title: task.title,
                dueDate: task.dueDate,
              });
            }
          }
        }
      }
    }

    return NextResponse.json({
      success: true,
      goal: createdGoal ? { id: createdGoal.id, title: createdGoal.title } : null,
      tasks: createdTasks,
      message: `Created ${createdTasks.length} deadline${createdTasks.length !== 1 ? "s" : ""} in your plan`,
    });
  } catch (error) {
    console.error("[Import Deadlines] Error:", error);
    return NextResponse.json(
      { error: "Failed to import deadlines" },
      { status: 500 }
    );
  }
}

// GET endpoint to fetch available deadlines for a school/program
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const type = searchParams.get("type");
    const sourceId = searchParams.get("sourceId");

    if (!type || !sourceId) {
      return NextResponse.json(
        { error: "Missing required params: type, sourceId" },
        { status: 400 }
      );
    }

    const profile = await prisma.studentProfile.findUnique({
      where: { userId: user.id },
      select: { id: true },
    });

    if (!profile) {
      return NextResponse.json({ error: "Profile not found" }, { status: 404 });
    }

    if (type === "school") {
      const currentCycle = getCurrentAdmissionsCycle();
      const school = await prisma.school.findUnique({
        where: { id: sourceId },
        include: {
          deadlineYears: {
            where: { admissionsCycle: currentCycle },
            take: 1,
          },
        },
      });

      if (!school) {
        return NextResponse.json({ error: "School not found" }, { status: 404 });
      }

      const yearDeadlines = school.deadlineYears[0];

      // Get existing tasks for this school
      const existingTasks = await prisma.task.findMany({
        where: {
          studentProfileId: profile.id,
          schoolId: sourceId,
        },
        select: { deadlineType: true },
      });

      const existingTypes = new Set(existingTasks.map(t => t.deadlineType));

      // Build available deadlines from SchoolDeadlineYear
      const deadlines = yearDeadlines
        ? Object.entries(SCHOOL_DEADLINE_TYPES).map(([key, info]) => {
            const date = yearDeadlines[info.field as keyof typeof yearDeadlines] as Date | null;
            return {
              type: key,
              label: info.label,
              taskType: info.type, // "milestone" or "action"
              date,
              alreadyAdded: existingTypes.has(key),
            };
          }).filter(d => d.date !== null)
        : [];

      return NextResponse.json({
        name: school.name,
        deadlines,
        admissionsCycle: currentCycle,
        // Also include the default action templates
        actionTemplates: DEFAULT_SCHOOL_ACTIONS.map(t => ({
          title: t.title,
          daysOffset: t.daysOffset,
          category: t.category,
        })),
      });
    } else if (type === "program") {
      const program = await prisma.summerProgram.findUnique({
        where: { id: sourceId },
      });

      if (!program) {
        return NextResponse.json({ error: "Program not found" }, { status: 404 });
      }

      // Get existing tasks for this program
      const existingTasks = await prisma.task.findMany({
        where: {
          studentProfileId: profile.id,
          summerProgramId: sourceId,
        },
        select: { deadlineType: true },
      });

      const existingTypes = new Set(existingTasks.map(t => t.deadlineType));

      // Build available deadlines
      const deadlines = Object.entries(PROGRAM_DEADLINE_TYPES).map(([key, info]) => {
        const date = program[info.field as keyof typeof program] as Date | null;
        return {
          type: key,
          label: info.label,
          taskType: info.type, // "milestone" or "action"
          date,
          alreadyAdded: existingTypes.has(key),
        };
      }).filter(d => d.date !== null);

      return NextResponse.json({
        name: program.name,
        shortName: program.shortName,
        deadlines,
        // Also include the default action templates
        actionTemplates: DEFAULT_PROGRAM_ACTIONS.map(t => ({
          title: t.title,
          daysOffset: t.daysOffset,
          category: t.category,
        })),
      });
    }

    return NextResponse.json({ error: "Invalid type" }, { status: 400 });
  } catch (error) {
    console.error("[Get Deadlines] Error:", error);
    return NextResponse.json(
      { error: "Failed to fetch deadlines" },
      { status: 500 }
    );
  }
}
