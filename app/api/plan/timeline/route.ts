import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { createClient } from "@/lib/supabase/server";

export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const profile = await prisma.studentProfile.findUnique({
      where: { userId: user.id },
      select: { id: true },
    });

    if (!profile) {
      return NextResponse.json({ error: "Profile not found" }, { status: 404 });
    }

    const { searchParams } = new URL(request.url);
    const filter = searchParams.get("filter") || "all"; // "all" | "schools" | "programs" | "goals" | "tests"
    const range = searchParams.get("range") || "upcoming"; // "upcoming" | "week" | "month" | "all"
    const includeCompleted = searchParams.get("completed") === "true";

    // Calculate date range
    const now = new Date();
    let startDate = now;
    let endDate: Date | undefined;

    if (range === "week") {
      endDate = new Date(now);
      endDate.setDate(endDate.getDate() + 7);
    } else if (range === "month") {
      endDate = new Date(now);
      endDate.setMonth(endDate.getMonth() + 1);
    }
    // "upcoming" and "all" don't have an end date

    // Build filter conditions
    const statusCondition = includeCompleted
      ? {}
      : { status: { not: "completed" } };

    const dateCondition = {
      dueDate: {
        not: null,
        gte: startDate,
        ...(endDate ? { lte: endDate } : {}),
      },
    };

    // Source type filter
    let sourceCondition = {};
    if (filter === "schools") {
      sourceCondition = { schoolId: { not: null } };
    } else if (filter === "programs") {
      sourceCondition = { summerProgramId: { not: null } };
    } else if (filter === "goals") {
      sourceCondition = {
        schoolId: null,
        summerProgramId: null,
        isAutoGenerated: false,
      };
    } else if (filter === "tests") {
      sourceCondition = { testType: { not: null } };
    }

    // Fetch tasks with due dates
    const tasks = await prisma.task.findMany({
      where: {
        studentProfileId: profile.id,
        ...statusCondition,
        ...dateCondition,
        ...sourceCondition,
      },
      include: {
        goal: {
          select: { id: true, title: true, category: true },
        },
        school: {
          select: { id: true, name: true, shortName: true },
        },
        summerProgram: {
          select: { id: true, name: true, shortName: true },
        },
        parentTask: {
          select: { id: true, title: true },
        },
      },
      orderBy: { dueDate: "asc" },
    });

    // Also fetch goals with target dates (if filter allows)
    let goals: Array<{
      id: string;
      title: string;
      targetDate: Date | null;
      category: string;
      status: string;
      school?: { id: string; name: string; shortName: string | null } | null;
      summerProgram?: { id: string; name: string; shortName: string | null } | null;
    }> = [];

    if (filter === "all" || filter === "goals") {
      goals = await prisma.goal.findMany({
        where: {
          studentProfileId: profile.id,
          targetDate: { not: null, gte: startDate, ...(endDate ? { lte: endDate } : {}) },
          ...(includeCompleted ? {} : { status: { not: "completed" } }),
        },
        include: {
          school: {
            select: { id: true, name: true, shortName: true },
          },
          summerProgram: {
            select: { id: true, name: true, shortName: true },
          },
        },
        orderBy: { targetDate: "asc" },
      });
    }

    // Combine and format timeline items
    const timelineItems = [
      ...tasks.map(task => ({
        id: task.id,
        type: "task" as const,
        taskType: (task.type || "action") as "milestone" | "action",
        title: task.title,
        description: task.description,
        dueDate: task.dueDate,
        status: task.status,
        priority: task.priority,
        // Source info
        sourceType: task.schoolId ? "school" : task.summerProgramId ? "program" : task.testType ? "test" : "manual",
        deadlineType: task.deadlineType,
        isHardDeadline: task.isHardDeadline,
        isAutoGenerated: task.isAutoGenerated,
        // Related entities
        goal: task.goal,
        school: task.school,
        program: task.summerProgram,
        parentTask: task.parentTask,
      })),
      ...goals.map(goal => ({
        id: goal.id,
        type: "goal" as const,
        taskType: "milestone" as const,  // Goals are milestones (target dates)
        title: goal.title,
        description: null,
        dueDate: goal.targetDate,
        status: goal.status,
        priority: null,
        // Source info
        sourceType: goal.school ? "school" : goal.summerProgram ? "program" : "manual",
        deadlineType: null,
        isHardDeadline: false,
        isAutoGenerated: false,
        // Related entities
        goal: null,
        school: goal.school,
        program: goal.summerProgram,
        parentTask: null,
      })),
    ].sort((a, b) => {
      if (!a.dueDate || !b.dueDate) return 0;
      return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime();
    });

    // Group by time period
    const grouped = groupByTimePeriod(timelineItems);

    return NextResponse.json({
      items: timelineItems,
      grouped,
      total: timelineItems.length,
      filter,
      range,
    });
  } catch (error) {
    console.error("[Timeline] Error:", error);
    return NextResponse.json(
      { error: "Failed to fetch timeline" },
      { status: 500 }
    );
  }
}

function groupByTimePeriod(items: Array<{ dueDate: Date | null; [key: string]: unknown }>) {
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  const endOfWeek = new Date(today);
  endOfWeek.setDate(today.getDate() + (7 - today.getDay()));

  const endOfNextWeek = new Date(endOfWeek);
  endOfNextWeek.setDate(endOfNextWeek.getDate() + 7);

  const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);

  const groups: Record<string, typeof items> = {
    overdue: [],
    today: [],
    thisWeek: [],
    nextWeek: [],
    thisMonth: [],
    later: [],
  };

  for (const item of items) {
    if (!item.dueDate) continue;

    const dueDate = new Date(item.dueDate);
    const dueDateOnly = new Date(dueDate.getFullYear(), dueDate.getMonth(), dueDate.getDate());

    if (dueDateOnly < today) {
      groups.overdue.push(item);
    } else if (dueDateOnly.getTime() === today.getTime()) {
      groups.today.push(item);
    } else if (dueDateOnly <= endOfWeek) {
      groups.thisWeek.push(item);
    } else if (dueDateOnly <= endOfNextWeek) {
      groups.nextWeek.push(item);
    } else if (dueDateOnly <= endOfMonth) {
      groups.thisMonth.push(item);
    } else {
      groups.later.push(item);
    }
  }

  return groups;
}
